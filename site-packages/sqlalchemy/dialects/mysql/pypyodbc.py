# mssql/pypyodbc.py
# Copyright (C) 2005-2015 the SQLAlchemy authors and contributors
# <see AUTHORS file>
#
# This module is part of SQLAlchemy and is released under
# the MIT License: http://www.opensource.org/licenses/mit-license.php

"""
.. dialect:: mssql+pypyodbc
    :name: pypyodbc
    :dbapi: pypyodbc
    :connectstring: mssql+pypyodbc://<username>:<password>@<dsnname>
    :url: http://pypi.python.org/pypi/pypyodbc/

Connecting to pypyodbc
--------------------

The URL here is to be translated to pypyodbc connection strings, as
detailed in `ConnectionStrings <https://code.google.com/p/pypyodbc/wiki/ConnectionStrings>`_.

DSN Connections
^^^^^^^^^^^^^^^

A DSN-based connection is **preferred** overall when using ODBC.  A
basic DSN-based connection looks like::

    engine = create_engine("mssql+pypyodbc://scott:tiger@some_dsn")

Which above, will pass the following connection string to pypyodbc::

    dsn=mydsn;UID=user;PWD=pass

If the username and password are omitted, the DSN form will also add
the ``Trusted_Connection=yes`` directive to the ODBC string.

Hostname Connections
^^^^^^^^^^^^^^^^^^^^

Hostname-based connections are **not preferred**, however are supported.
The ODBC driver name must be explicitly specified::

    engine = create_engine("mssql+pypyodbc://scott:tiger@myhost:port/databasename?driver=SQL+Server+Native+Client+10.0")

.. versionchanged:: 1.0.0 Hostname-based pypyodbc connections now require the
   SQL Server driver name specified explicitly.  SQLAlchemy cannot
   choose an optimal default here as it varies based on platform
   and installed drivers.

Other keywords interpreted by the pypyodbc dialect to be passed to
``pypyodbc.connect()`` in both the DSN and hostname cases include:
``odbc_autotranslate``, ``ansi``, ``unicode_results``, ``autocommit``.

Pass through exact pypyodbc string
^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

A pypyodbc connection string can also be sent exactly as specified in
`ConnectionStrings <https://code.google.com/p/pypyodbc/wiki/ConnectionStrings>`_
into the driver using the parameter ``odbc_connect``.  The delimeters must be URL escaped, however,
as illustrated below using ``urllib.quote_plus``::

    import urllib
    params = urllib.quote_plus("DRIVER={SQL Server Native Client 10.0};SERVER=dagger;DATABASE=test;UID=user;PWD=password")

    engine = create_engine("mssql+pypyodbc:///?odbc_connect=%s" % params)


Unicode Binds
-------------

The current state of pypyodbc on a unix backend with FreeTDS and/or
EasySoft is poor regarding unicode; different OS platforms and versions of
UnixODBC versus IODBC versus FreeTDS/EasySoft versus pypyodbc itself
dramatically alter how strings are received.  The pypyodbc dialect attempts to
use all the information it knows to determine whether or not a Python unicode
literal can be passed directly to the pypyodbc driver or not; while SQLAlchemy
can encode these to bytestrings first, some users have reported that pypyodbc
mis-handles bytestrings for certain encodings and requires a Python unicode
object, while the author has observed widespread cases where a Python unicode
is completely misinterpreted by pypyodbc, particularly when dealing with
the information schema tables used in table reflection, and the value
must first be encoded to a bytestring.

It is for this reason that whether or not unicode literals for bound
parameters be sent to pypyodbc can be controlled using the
``supports_unicode_binds`` parameter to ``create_engine()``.  When
left at its default of ``None``, the pypyodbc dialect will use its
best guess as to whether or not the driver deals with unicode literals
well.  When ``False``, unicode literals will be encoded first, and when
``True`` unicode literals will be passed straight through.  This is an interim
flag that hopefully should not be needed when the unicode situation stabilizes
for unix + pypyodbc.

.. versionadded:: 0.7.7
    ``supports_unicode_binds`` parameter to ``create_engine()``\ .

"""

from .base import MSExecutionContext, MSDialect, VARBINARY
from ...connectors.pypyodbc import pypyodbcConnector
from ... import types as sqltypes, util
import decimal


class _ms_numeric_pypyodbc(object):

    """Turns Decimals with adjusted() < 0 or > 7 into strings.

    The routines here are needed for older pypyodbc versions
    as well as current mxODBC versions.

    """

    def bind_processor(self, dialect):

        super_process = super(_ms_numeric_pypyodbc, self).\
            bind_processor(dialect)

        if not dialect._need_decimal_fix:
            return super_process

        def process(value):
            if self.asdecimal and \
                    isinstance(value, decimal.Decimal):

                adjusted = value.adjusted()
                if adjusted < 0:
                    return self._small_dec_to_string(value)
                elif adjusted > 7:
                    return self._large_dec_to_string(value)

            if super_process:
                return super_process(value)
            else:
                return value
        return process

    # these routines needed for older versions of pypyodbc.
    # as of 2.1.8 this logic is integrated.

    def _small_dec_to_string(self, value):
        return "%s0.%s%s" % (
            (value < 0 and '-' or ''),
            '0' * (abs(value.adjusted()) - 1),
            "".join([str(nint) for nint in value.as_tuple()[1]]))

    def _large_dec_to_string(self, value):
        _int = value.as_tuple()[1]
        if 'E' in str(value):
            result = "%s%s%s" % (
                (value < 0 and '-' or ''),
                "".join([str(s) for s in _int]),
                "0" * (value.adjusted() - (len(_int) - 1)))
        else:
            if (len(_int) - 1) > value.adjusted():
                result = "%s%s.%s" % (
                    (value < 0 and '-' or ''),
                    "".join(
                        [str(s) for s in _int][0:value.adjusted() + 1]),
                    "".join(
                        [str(s) for s in _int][value.adjusted() + 1:]))
            else:
                result = "%s%s" % (
                    (value < 0 and '-' or ''),
                    "".join(
                        [str(s) for s in _int][0:value.adjusted() + 1]))
        return result


class _MSNumeric_pypyodbc(_ms_numeric_pypyodbc, sqltypes.Numeric):
    pass


class _MSFloat_pypyodbc(_ms_numeric_pypyodbc, sqltypes.Float):
    pass


class _VARBINARY_pypyodbc(VARBINARY):
    def bind_processor(self, dialect):
        if dialect.dbapi is None:
            return None

        DBAPIBinary = dialect.dbapi.Binary

        def process(value):
            if value is not None:
                return DBAPIBinary(value)
            else:
                # pypyodbc-specific
                return dialect.dbapi.BinaryNull
        return process


class MSExecutionContext_pypyodbc(MSExecutionContext):
    _embedded_scope_identity = False

    def pre_exec(self):
        """where appropriate, issue "select scope_identity()" in the same
        statement.

        Background on why "scope_identity()" is preferable to "@@identity":
        http://msdn.microsoft.com/en-us/library/ms190315.aspx

        Background on why we attempt to embed "scope_identity()" into the same
        statement as the INSERT:
        http://code.google.com/p/pypyodbc/wiki/FAQs#How_do_I_retrieve_autogenerated/identity_values?

        """

        super(MSExecutionContext_pypyodbc, self).pre_exec()

        # don't embed the scope_identity select into an
        # "INSERT .. DEFAULT VALUES"
        if self._select_lastrowid and \
                self.dialect.use_scope_identity and \
                len(self.parameters[0]):
            self._embedded_scope_identity = True

            self.statement += "; select scope_identity()"

    def post_exec(self):
        if self._embedded_scope_identity:
            # Fetch the last inserted id from the manipulated statement
            # We may have to skip over a number of result sets with
            # no data (due to triggers, etc.)
            while True:
                try:
                    # fetchall() ensures the cursor is consumed
                    # without closing it (FreeTDS particularly)
                    row = self.cursor.fetchall()[0]
                    break
                except self.dialect.dbapi.Error as e:
                    # no way around this - nextset() consumes the previous set
                    # so we need to just keep flipping
                    self.cursor.nextset()

            self._lastrowid = int(row[0])
        else:
            super(MSExecutionContext_pypyodbc, self).post_exec()


class MSDialect_pypyodbc(pypyodbcConnector, MSDialect):

    execution_ctx_cls = MSExecutionContext_pypyodbc

    colspecs = util.update_copy(
        MSDialect.colspecs,
        {
            sqltypes.Numeric: _MSNumeric_pypyodbc,
            sqltypes.Float: _MSFloat_pypyodbc,
            VARBINARY: _VARBINARY_pypyodbc,
            sqltypes.LargeBinary: _VARBINARY_pypyodbc,
        }
    )

    def __init__(self, description_encoding=None, **params):
        if 'description_encoding' in params:
            self.description_encoding = params.pop('description_encoding')
        super(MSDialect_pypyodbc, self).__init__(**params)
        self.use_scope_identity = self.use_scope_identity and \
            self.dbapi and \
            hasattr(self.dbapi.Cursor, 'nextset')
        self._need_decimal_fix = self.dbapi and \
            self._dbapi_version() < (2, 1, 8)

dialect = MSDialect_pypyodbc
